[
  {
    "id": "C-01",
    "title": "Lack of Protected Routes Exposes All Pages",
    "severity": "Critical",
    "location": "src/App.jsx",
    "evidence": "The <Routes> component in App.jsx defines all routes as public. There is no wrapper component or logic to check for useAuth().session before rendering routes like /session or /analytics.",
    "rootCause": "The application was built without a centralized routing protection mechanism. Authorization logic was likely intended to be handled individually inside each page component, which is an insecure and unmaintainable design pattern.",
    "impact": "Critical security risk. Any user can access any part of the application by simply navigating to the URL. This could expose sensitive user data or application functionality that should be restricted to authenticated users.",
    "risk": "Low. Implementing a standard protected route component is a common pattern in React. However, it may reveal that child components were implicitly relying on being unprotected, causing some initial breakage that would need to be fixed.",
    "confidence": "High",
    "questions": "Was it an intentional design decision to handle authorization inside each page component? Are there any pages that are intended to be public even if they seem like they should be private?"
  },
  {
    "id": "C-02",
    "title": "Flawed Auth Provider and Mocking Strategy",
    "severity": "Critical",
    "location": "src/contexts/AuthContext.tsx",
    "evidence": "The provider's useEffect hook is entirely bypassed if window.__E2E_MOCK_SESSION__ exists. The render method also returns null during loading states.",
    "rootCause": "The E2E mocking was implemented as a shortcut to avoid dealing with the complexity of mocking Supabase auth listeners. This shortcut created a fundamentally different code path for tests vs. production. The unsafe rendering was likely an oversight.",
    "impact": "High test instability and low confidence in tests. The component's core logic is never actually tested in the E2E suite. This is the likely root cause of the test flakiness and AuthContext bugs mentioned in the PRD. The !loading && children pattern causes a poor user experience with content flickering on page load.",
    "risk": "Medium. Refactoring the E2E tests to properly mock Supabase instead of bypassing the provider will require significant effort and will likely uncover many hidden bugs in the UI's response to auth state changes.",
    "confidence": "High",
    "questions": "Why was the decision made to bypass the provider in E2E tests instead of mocking the supabase client at a lower level?"
  },
  {
    "id": "C-03",
    "title": "Anonymous User Flow is Broken",
    "severity": "Critical",
    "location": "src/hooks/useSessionManager.js",
    "evidence": "The saveSession function for anonymous users creates a temporary, in-memory object and returns it. The data is never persisted to any form of storage (localStorage, sessionStorage, etc.).",
    "rootCause": "The developer implemented the 'save' logic for an anonymous user without considering that the user needs to navigate to a new page (/analytics) to view the results. The data is correctly captured but never stored anywhere accessible to the next page.",
    "impact": "Critical. The primary user acquisition funnel is broken. A new user's first experience with the product will be to complete a session and then see a blank or broken analytics page, which will likely cause them to abandon the product.",
    "risk": "Medium. A solution requires deciding on a storage mechanism for anonymous session data (e.g., sessionStorage) and refactoring the analytics page to read from this location. This change touches multiple components.",
    "confidence": "High",
    "questions": "What was the intended mechanism for passing anonymous session data from the /session page to the /analytics page?"
  },
  {
    "id": "C-04",
    "title": "Premium Users Do Not Receive Paid Features",
    "severity": "Critical",
    "location": "src/services/transcription/TranscriptionService.js",
    "evidence": "The logic to enable the high-accuracy cloud transcription service only checks for 'pro' users and ignores 'premium' users.",
    "rootCause": "This is likely an oversight. When the 'Premium' tier was conceptualized or added, this critical piece of business logic was not updated to include it.",
    "impact": "Critical. This is a direct monetization bug. Users paying for the 'Premium' tier are not receiving the features they paid for and are instead getting the free user experience. This can lead to customer complaints, chargebacks, and damage to the brand's reputation.",
    "risk": "Low. The fix is likely a one-line change to include this.profile.is_premium_user in the condition. However, it's critical to verify if is_premium_user is the correct property on the profile object.",
    "confidence": "High",
    "questions": "What is the correct property on the user profile to identify a 'Premium' user? Is it subscription_status === 'premium' or a boolean flag like is_premium_user?"
  },
  {
    "id": "H-01",
    "title": "Unstable and Unreliable Test Suite",
    "severity": "High",
    "location": "package.json, playwright.config.ts, src/pages/__tests__/AuthPage.test.jsx",
    "evidence": "1. package.json forces sequential execution for Vitest (`--poolOptions.forks.maxForks=1`) and allocates extra memory (`--max-old-space-size=8192`). 2. playwright.config.ts forces sequential execution for E2E tests (`workers: 1`). 3. Component tests like AuthPage.test.jsx do not use the mandated `renderWithAllProviders` helper and use improper mock cleanup (`vi.clearAllMocks` instead of `vi.restoreAllMocks`).",
    "rootCause": "The test suite is unstable due to systemic bad practices. State from contexts and mocks is leaking between tests, causing non-deterministic failures when run in parallel. The memory leak is likely caused by not cleaning up Supabase listeners, which the `renderWithAllProviders` helper was designed to solve.",
    "impact": "High. The development team cannot trust the test suite. This slows down development, erodes confidence in the CI/CD pipeline, and allows bugs to slip into production. The workarounds (sequential execution) increase test run times, further slowing down feedback loops.",
    "risk": "High. Fixing this requires a significant, project-wide effort to refactor all existing tests to use the correct helpers and best practices. This is a large but necessary undertaking to pay down critical technical debt.",
    "confidence": "High",
    "questions": "Is the team aware that the test instability is likely caused by not using the `renderWithAllProviders` helper and improper mock cleanup?"
  },
  {
    "id": "H-02",
    "title": "Critical Monetization Flow is Untested",
    "severity": "High",
    "location": "tests/e2e.spec.ts",
    "evidence": "The main E2E test file contains tests for the native and cloud transcription modes, but there is no test case that simulates a free user exhausting their monthly quota and being prompted to upgrade. The CHANGELOG.md claims this test was added, but it is not present in the code.",
    "rootCause": "The changelog entry was either a mistake, or it refers to a change on a different branch that was never merged. The test was likely never written due to the overall instability of the E2E environment.",
    "impact": "High. A core business and monetization flow is not covered by automated testing. This means a bug in the quota enforcement or upgrade prompt could go unnoticed, directly impacting the company's ability to convert free users to paid customers.",
    "risk": "Medium. Creating the test requires the E2E environment to be stable enough to handle the multi-step user journey. The AuthContext bugs would likely need to be fixed first.",
    "confidence": "High",
    "questions": "Is there a reason the 'Free User Quota' E2E test was not implemented? Was it blocked by the test environment instability?"
  },
  {
    "id": "H-03",
    "title": "Inefficient Database Schema Design",
    "severity": "High",
    "location": "supabase/migrations/20250811062708_initial_schema.sql",
    "evidence": "The initial schema uses a subquery in the RLS policy for the sessions table (`(select auth.uid()) = user_id`) and lacks an index on the sessions.user_id foreign key.",
    "rootCause": "This was likely an oversight during the initial design, stemming from a lack of deep expertise in PostgreSQL performance tuning.",
    "impact": "High. The lack of an index on user_id would cause SELECT queries for a user's sessions to become progressively slower as the table grows, leading to a poor user experience (e.g., slow loading of the analytics page). The inefficient RLS policy adds overhead to all queries on the table. (Note: This appears to have been fixed in later migrations, but it's a significant flaw in the initial design).",
    "risk": "Low (as it seems to be already fixed). The fix involves rewriting the policy and and adding an index, both of which are standard database operations.",
    "confidence": "High",
    "questions": "Are you confident that all performance issues related to RLS policies and missing indexes have been found and fixed?"
  },
  {
    "id": "H-04",
    "title": "Fragile 'Pass-the-Parcel' State Management",
    "severity": "High",
    "location": "src/contexts/SessionContext.jsx, src/hooks/useSessionManager.js",
    "evidence": "useSessionManager.js returns a newly saved session object to its calling component. That component is then expected to manually call SessionContext.addSession to update the global state.",
    "rootCause": "This is an architectural choice that avoids tight coupling between the hook and the context, but it does so at the cost of robustness. It creates an implicit contract that is easy for a developer to forget, leading to UI bugs.",
    "impact": "High. This design pattern is a common source of bugs where the UI becomes stale or fails to update after an action. It makes the code harder to reason about and maintain, as the responsibility for state updates is spread across multiple components instead of being centralized.",
    "risk": "Medium. Refactoring this would involve creating a more robust state management solution, perhaps by having useSessionManager dispatch updates to a reducer or directly call the context's update function itself. This would be a significant but beneficial architectural change.",
    "confidence": "High",
    "questions": "Was this decoupled state management pattern an intentional architectural choice? Are you aware of the risks it poses for UI consistency?"
  },
  {
    "id": "M-01",
    "title": "Systemic Documentation Failure",
    "severity": "Medium",
    "location": "/docs/ directory, CHANGELOG.md",
    "evidence": "There are numerous direct contradictions between PRD.md, ROADMAP.md, and CHANGELOG.md regarding the status of the test suite, the existence of E2E tests, and the implementation of key features. The documentation is not synchronized.",
    "rootCause": "The project lacks a disciplined process for updating all relevant documentation after code changes are made. The 'Gating Checks' in the roadmap, which call for this, are all marked as 'Not Started'.",
    "impact": "Medium. The documentation cannot be trusted. This wastes developer time, creates confusion, and makes it difficult for new contributors (or AI agents) to understand the true state of the project. It negates the value of having documentation in the first place.",
    "risk": "Low. The fix is process-based. It requires enforcing the rule that documentation must be updated as part of the definition of 'done' for any task.",
    "confidence": "High",
    "questions": "What is the current process for ensuring documentation is kept in sync with the code? How can it be improved?"
  },
  {
    "id": "M-02",
    "title": "Silent Downgrade of Service for Pro Users",
    "severity": "Medium",
    "location": "src/services/transcription/TranscriptionService.js",
    "evidence": "If the getAssemblyAIToken call fails for a Pro user, the service logs a warning and proceeds to use the lower-quality NativeBrowser provider without ever informing the user of the downgrade.",
    "rootCause": "This was likely an oversight in error handling logic. The developer handled the failure case technically but did not consider the user experience implications.",
    "impact": "Medium. Paying customers may receive a degraded service without their knowledge, leading to a poor user experience and a perception that the product is low quality. It erodes user trust.",
    "risk": "Low. The fix involves adding a mechanism to inform the user of the downgrade, likely via a toast notification or a status indicator in the UI.",
    "confidence": "High",
    "questions": "What is the desired user experience when a premium service fails and a fallback is used?"
  },
  {
    "id": "L-01",
    "title": "Non-Existent On-Device Feature",
    "severity": "Low",
    "location": "src/services/transcription/TranscriptionService.js",
    "evidence": "The TranscriptionService has no imports or logic related to a LocalWhisper or any other on-device transcription provider, despite it being mentioned in the PRD and Architecture documents.",
    "rootCause": "The feature was planned and documented but never implemented. The documentation was not updated to reflect that it is still just a 'future' item.",
    "impact": "Low (currently). The primary impact is on documentation accuracy. However, if the company were to market this feature based on the outdated documentation, it would be a significant problem.",
    "risk": "N/A. There is nothing to fix in the code. The documentation should be updated to accurately reflect the feature's status as 'Not Started'.",
    "confidence": "High",
    "questions": "Should the documentation be updated to remove references to the on-device feature needing 'polish' and clarify that it is not yet implemented?"
  }
]
