import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';

// Mock the deepest dependencies of TranscriptionService first to prevent memory leaks.
vi.mock('../services/transcription/modes/CloudAssemblyAI', () => ({
  default: vi.fn().mockImplementation(() => ({
    init: vi.fn().mockResolvedValue(undefined),
    startTranscription: vi.fn().mockResolvedValue(undefined),
    stopTranscription: vi.fn().mockResolvedValue(undefined),
    destroy: vi.fn().mockResolvedValue(undefined),
  })),
}));

vi.mock('../services/transcription/modes/NativeBrowser', () => ({
  default: vi.fn().mockImplementation(() => ({
    init: vi.fn().mockResolvedValue(undefined),
    startTranscription: vi.fn().mockResolvedValue(undefined),
    stopTranscription: vi.fn().mockResolvedValue(undefined),
    destroy: vi.fn().mockResolvedValue(undefined),
  })),
}));

// Mock other dependencies
vi.mock('sonner', () => ({
  toast: {
    error: vi.fn(),
    success: vi.fn(),
    info: vi.fn(),
  },
}));

vi.mock('../config', () => ({
  FILLER_WORD_KEYS: {
    UM: 'um',
    UH: 'uh',
    AH: 'ah',
    LIKE: 'like',
    YOU_KNOW: 'you_know',
    SO: 'so',
    ACTUALLY: 'actually',
    OH: 'oh',
    I_MEAN: 'i_mean',
  },
}));

vi.mock('../contexts/AuthContext', () => ({
  useAuth: vi.fn(() => ({
    user: { id: 'test-user-id' },
    profile: { subscription_status: 'free' },
  })),
}));

// Create a simple mock service that can be controlled in tests
const mockServiceInstance = {
  init: vi.fn().mockResolvedValue(),
  startTranscription: vi.fn().mockResolvedValue(),
  stopTranscription: vi.fn().mockResolvedValue(),
  destroy: vi.fn().mockResolvedValue(),
  on: vi.fn(),
  off: vi.fn(),
  mode: 'cloud',
  forceCloud: false,
};

vi.mock('../services/transcription/TranscriptionService', () => ({
  default: vi.fn(() => mockServiceInstance),
}));

// Import after mocks
import { useSpeechRecognition } from '../hooks/useSpeechRecognition';
import TranscriptionService from '../services/transcription/TranscriptionService';

describe('useSpeechRecognition', () => {
  beforeEach(() => {
    // Reset all mocks before each test to ensure isolation
    vi.clearAllMocks();
    // Also reset the mock service's functions to their base implementation
    mockServiceInstance.init.mockResolvedValue();
    mockServiceInstance.startTranscription.mockResolvedValue();
    mockServiceInstance.stopTranscription.mockResolvedValue();
    mockServiceInstance.destroy.mockResolvedValue();
  });

  it('should initialize with default state', () => {
    const { result } = renderHook(() => useSpeechRecognition());

    expect(result.current.isListening).toBe(false);
    expect(result.current.isReady).toBe(false);
    expect(result.current.transcript).toBe('');
    expect(result.current.interimTranscript).toBe('');
    expect(result.current.error).toBeNull();
  });

  it('should start listening and create service', async () => {
    const { result } = renderHook(() => useSpeechRecognition());

    await act(async () => {
      await result.current.startListening();
    });

    expect(TranscriptionService).toHaveBeenCalledOnce();
    expect(mockServiceInstance.init).toHaveBeenCalledOnce();
    expect(mockServiceInstance.startTranscription).toHaveBeenCalledOnce();
    expect(result.current.isListening).toBe(true);
  });

  it('should stop listening', async () => {
    const { result } = renderHook(() => useSpeechRecognition());

    // Start first
    await act(async () => {
      await result.current.startListening();
    });

    // Then stop
    await act(async () => {
      await result.current.stopListening();
    });

    expect(mockServiceInstance.stopTranscription).toHaveBeenCalledOnce();
    expect(result.current.isListening).toBe(false);
  });

  it('should call destroy on unmount', () => {
    const { unmount } = renderHook(() => useSpeechRecognition());

    // unmount is now called automatically by cleanup-after-each,
    // so we just need to verify destroy was called.
    // But how to test that? The cleanup happens *after* the test body.
    // The best way is to trust the cleanup and ensure the test passes.
    // We can, however, manually unmount to test the behavior explicitly.
    unmount();
    expect(mockServiceInstance.destroy).toHaveBeenCalledOnce();
  });
});
