import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';

// Simple, direct mocking - no vi.hoisted() complexity

// Mock heavy dependencies first
vi.mock('@xenova/transformers', () => ({}));

vi.mock('sonner', () => ({
  toast: {
    error: vi.fn(),
    success: vi.fn(),
    info: vi.fn(),
  },
}));

vi.mock('../config', () => ({
  FILLER_WORD_KEYS: {
    UM: 'um',
    UH: 'uh',
    AH: 'ah',
    LIKE: 'like',
    YOU_KNOW: 'you_know',
    SO: 'so',
    ACTUALLY: 'actually',
    OH: 'oh',
    I_MEAN: 'i_mean',
  },
}));

vi.mock('../contexts/AuthContext', () => ({
  useAuth: vi.fn(() => ({
    user: { id: 'test-user-id' },
    profile: { subscription_status: 'free' },
  })),
}));

// Create a simple mock service
const createMockService = () => ({
  init: vi.fn().mockResolvedValue(),
  startTranscription: vi.fn().mockResolvedValue(),
  stopTranscription: vi.fn().mockResolvedValue(),
  destroy: vi.fn().mockResolvedValue(),
  mode: 'cloud',
  forceCloud: false,
});

let mockServiceInstance = createMockService();

vi.mock('../services/transcription/TranscriptionService', () => ({
  default: vi.fn(() => mockServiceInstance),
}));

// Import after mocks
import { useSpeechRecognition } from '../hooks/useSpeechRecognition';

describe('useSpeechRecognition', () => {
  beforeEach(() => {
    // Reset the mock service instance
    mockServiceInstance = createMockService();
    vi.clearAllMocks();
  });

  it('should initialize with default state', () => {
    const { result } = renderHook(() => useSpeechRecognition());

    expect(result.current.isListening).toBe(false);
    expect(result.current.isReady).toBe(false);
    expect(result.current.transcript).toBe('');
    expect(result.current.interimTranscript).toBe('');
    expect(result.current.error).toBeNull();
  });

  it('should start listening and create service', async () => {
    const { result } = renderHook(() => useSpeechRecognition());

    await act(async () => {
      await result.current.startListening();
    });

    expect(mockServiceInstance.init).toHaveBeenCalled();
    expect(mockServiceInstance.startTranscription).toHaveBeenCalled();
    expect(result.current.isListening).toBe(true);
  });

  it('should stop listening', async () => {
    const { result } = renderHook(() => useSpeechRecognition());

    // Start first
    await act(async () => {
      await result.current.startListening();
    });

    // Then stop
    await act(async () => {
      await result.current.stopListening();
    });

    expect(mockServiceInstance.stopTranscription).toHaveBeenCalled();
    expect(result.current.isListening).toBe(false);
  });

  it('should reset state', () => {
    const { result } = renderHook(() => useSpeechRecognition());

    act(() => {
      result.current.reset();
    });

    expect(result.current.transcript).toBe('');
    expect(result.current.interimTranscript).toBe('');
    expect(result.current.error).toBeNull();
  });
});
