const werCache = new Map<string, number>();

/**
 * Calculates the Word Error Rate (WER) between a reference and a hypothesis string.
 * Uses a memory-optimized 1D DP array (Int32Array) for Levenshtein distance.
 * 
 * @param {string} reference - The ground truth transcript.
 * @param {string} hypothesis - The transcript generated by the STT engine.
 * @returns {number} The Word Error Rate.
 */
export const calculateWordErrorRate = (reference: string, hypothesis: string): number => {
  // Normalization & Early exits
  const refWords = reference.toLowerCase().trim().split(/\s+/).filter(Boolean);
  const hypWords = hypothesis.toLowerCase().trim().split(/\s+/).filter(Boolean);

  if (refWords.length === 0) return hypWords.length;
  if (hypWords.length === 0) return 1.0;

  // Cache lookup
  const cacheKey = `${reference}|${hypothesis}`;
  if (werCache.has(cacheKey)) {
    return werCache.get(cacheKey)!;
  }

  // Levenshtein distance using 1D DP array (memory: O(hypWords))
  // We iterate through refWords (rows) and update the 1D array (cols)
  const n = refWords.length;
  const m = hypWords.length;

  // dp stores the current row of the Levenshtein matrix
  const dp = new Int32Array(m + 1);

  // Initial state: distance from empty string to hypothesis prefix
  for (let j = 0; j <= m; j++) {
    dp[j] = j;
  }

  for (let i = 1; i <= n; i++) {
    let prevDiagonal = dp[0]; // Represents dp[i-1][j-1]
    dp[0] = i; // Represents dp[i][0]

    for (let j = 1; j <= m; j++) {
      const temp = dp[j];
      const cost = refWords[i - 1] === hypWords[j - 1] ? 0 : 1;

      // dp[j] is dp[i-1][j] (Deletion)
      // dp[j-1] is dp[i][j-1] (Insertion)
      // prevDiagonal is dp[i-1][j-1] (Substitution)
      dp[j] = Math.min(
        dp[j] + 1,           // Deletion
        dp[j - 1] + 1,       // Insertion
        prevDiagonal + cost  // Substitution
      );

      prevDiagonal = temp;
    }
  }

  const result = dp[m] / n;

  // Cache management (LRU-ish eviction)
  if (werCache.size > 1000) {
    const firstKey = werCache.keys().next().value;
    if (firstKey !== undefined) werCache.delete(firstKey);
  }
  werCache.set(cacheKey, result);

  return result;
};